<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="道阻且长,行则将至">
<meta property="og:type" content="website">
<meta property="og:title" content="上任鹅城">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="上任鹅城">
<meta property="og:description" content="道阻且长,行则将至">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="马帅傅">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>上任鹅城</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">上任鹅城</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/07/Vue2.x%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/07/Vue2.x%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/" class="post-title-link" itemprop="url">Vue2.x的依赖收集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-07 11:36:00" itemprop="dateCreated datePublished" datetime="2023-11-07T11:36:00+08:00">2023-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2023/11/07/Vue2.x%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的依赖收集" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/11/07/Vue2.x%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/11/07/Vue2.x%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Vue是一个实现了数据驱动的框架， 当数据改变的时候，需要通知到依赖这个数据的订阅者watcher。将数据和依赖数据的订阅者watcher联系起来的过程，称为依赖收集。</p>
<h4 id="收集过程"><a href="#收集过程" class="headerlink" title="收集过程"></a>收集过程</h4><p>一般来讲，数据的订阅者watcher常见的类型有如下3种：</p>
<ol>
<li>computed watcher</li>
<li>user watcher</li>
<li>render watcher</li>
</ol>
<p>不同类型的watcher完成依赖收集是有顺序的，比如上面提到的3种类型watcher执行顺序就是：computed watcher -&gt; user watcher -&gt; render watcher。</p>
<p>下面按顺序来分析3种watcher完成依赖收集的过程：</p>
<h5 id="computed-watcher"><a href="#computed-watcher" class="headerlink" title="computed watcher"></a>computed watcher</h5><p>在初始化数据的时候，如果组件中有使用computed计算属性，会执行initComputed方法，一个computed属性对应生成一个computed watcher。computed watcher是惰性的，不会马上执行watcher实例的get方法，watcher实例的get方法是依赖收集的一个关键方法，也就是说初始化computed的时候是没有做依赖收集的。</p>
<p>当后面使用到computed属性时，如template模版中第一次使用到计算属性，会执行computed对应watcher的get方法。</p>
<p>在这里插入对依赖管理器的介绍，帮助理解后续的过程。对于每一个被用到的响应式数据，都需要有一个dep实例来管理依赖这个数据的watcher。构造函数Dep有一个静态属性target，可以理解成一个全局变量，开始当前watcher的依赖收集的时候，就将当前依赖收集的watcher赋值给target。结束当前watcher的依赖收集的时候，将target赋值为watcher栈里的最上层的一个watcher。从上面的描述中可以看出，在做依赖收集的时候，是按watcher顺序执行来完成依赖收集的。</p>
<p>在get方法中会将当前的watcher压入watcher栈中，并将依赖管理器Dep的静态属性target赋值为当前watcher。然后执行当前watcher实例的getter方法，也就是computed属性对应的计算方法，里面涉及到对响应式数据的取值操作，就会执行数据的getter方法（为了跟前面的get方法区别开，使用getter）。</p>
<p>这里注意一下响应式数据，在执行initComputed之前，数据都是已经被数据劫持过的，使用的是Object.defineProperty方法。所以在对响应式数据取值的时候，才会执行数据的getter方法。</p>
<p>在getter方法中，除了取值还做了依赖收集的工作。判断Dep.target是否存在，如果存在就执行dep实例的depend方法，而dep.depend方法中调用的是当前watcher的addDep方法。</p>
<p>因为在前面的get方法中完成了computed watcher的压栈，所以这个时候的Dep.target是存在的，且值为computed watcher，会顺利执行到当前watcher的addDep方法。</p>
<p>在watcher.addDep方法中做了两件事，通过id来避免了重复收集：</p>
<ol>
<li>判断当前的watcher是否有收集关于当前dep实例的信息，如果没有则收集到自己的属性中；</li>
<li>判断当前的dep实例是否有收集当前watcher的信息，如果没有则收集到自己的属性中。</li>
</ol>
<p>watcher.addDep执行完成后，接着执行computed属性对应的计算方法，对使用到的响应式数据都完成依赖收集。完成依赖收集之后，将当前的watcher出栈。最后完成一个细节，遍历deps属性移除旧的订阅，更新为新的订阅。一些列操作完成之后，开始下一个watcher的依赖收集。</p>
<h5 id="user-watcher"><a href="#user-watcher" class="headerlink" title="user watcher"></a>user watcher</h5><p>在初始化数据的时候， 如果组件中有使用watch监听属性，会执行initWatch方法，一个watch属性对应生成一个user watcher。创建user watcher实例之后，会马上执行实例的get方法。</p>
<p>在get方法中也会将当前的watcher压入watcher栈中，并将依赖管理器Dep的静态属性target赋值为当前watcher。</p>
<p>执行当前watcher实例的getter方法，这个getter方法是在创建实例的时候执行parsePath方法返回的一个方法，会从Vue实例中获取到当前watch属性的值。因为watch的属性都是响应式数据，所以取值的时候会执行数据的getter方法。</p>
<p>在getter方法中，除了取值还做了依赖收集的工作。判断Dep.target是否存在，如果存在就执行dep实例的depend方法，而dep.depend方法中调用的是当前watcher的addDep方法。</p>
<p>因为在前面的get方法中完成了user watcher的压栈，所以这个时候的Dep.target是存在的，且值为user watcher，会顺利执行到当前watcher的addDep方法。</p>
<p>在watcher.addDep方法中做了两件事，通过id来避免了重复收集：</p>
<ol>
<li>判断当前的watcher是否有收集关于当前dep实例的信息，如果没有则收集到自己的属性中；</li>
<li>判断当前的dep实例是否有收集当前watcher的信息，如果没有则收集到自己的属性中。</li>
</ol>
<p>watcher.addDep执行完成后，将当前的watcher出栈。最后也是完成一个细节，遍历deps属性移除旧的订阅，更新为新的订阅。一些列操作完成之后，开始下一个watcher的依赖收集。</p>
<h5 id="render-watcher"><a href="#render-watcher" class="headerlink" title="render watcher"></a>render watcher</h5><p>初始化数据完成之后，对Vue实例进行挂载。将VNode渲染成DOM的方法作为创建watcher的第二个参数，创建了一个render watcher，一个组件实例对应一个render watcher。创建render watcher实例之后，会马上执行实例的get方法。</p>
<p>在get方法中也会将当前的watcher压入watcher栈中，并将依赖管理器Dep的静态属性target赋值为当前watcher。</p>
<p>执行当前watcher实例的getter方法，也就是将VNode渲染成DOM的方法（创建watcher实例时传入的第二个参数），在创建DOM的时候，需要对响应式数据进行取值，这就会执行数据的getter方法。</p>
<p>在getter方法中，除了取值还做了依赖收集的工作。判断Dep.target是否存在，如果存在就执行dep实例的depend方法，而dep.depend方法中调用的是当前watcher的addDep方法。</p>
<p>因为在前面的get方法中完成了render watcher的压栈，所以这个时候的Dep.target是存在的，且值为user watcher，会顺利执行到当前watcher的addDep方法。</p>
<p>在watcher.addDep方法中做了两件事，通过id来避免了重复收集：</p>
<ol>
<li>判断当前的watcher是否有收集关于当前dep实例的信息，如果没有则收集到自己的属性中；</li>
<li>判断当前的dep实例是否有收集当前watcher的信息，如果没有则收集到自己的属性中。</li>
</ol>
<p>watcher.addDep执行完成后，将当前的watcher出栈。最后也是完成一个细节，遍历deps属性移除旧的订阅，更新为新的订阅。一些列操作完成之后，开始下一个watcher的依赖收集。</p>
<h4 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h4><p>这三种watcher的其实大同小异，主要差别在于两点：</p>
<ol>
<li>实例的get方法执行时机不一样；</li>
<li>实例的getter方法不一样，可以根据需求自定义。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/07/Vue2.x%E7%9A%84%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/07/Vue2.x%E7%9A%84%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F/" class="post-title-link" itemprop="url">Vue2.x的数组响应式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-07 11:36:00" itemprop="dateCreated datePublished" datetime="2023-11-07T11:36:00+08:00">2023-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2023/11/07/Vue2.x%E7%9A%84%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的数组响应式" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/11/07/Vue2.x%E7%9A%84%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/11/07/Vue2.x%E7%9A%84%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="数组响应式的限制"><a href="#数组响应式的限制" class="headerlink" title="数组响应式的限制"></a>数组响应式的限制</h4><p>Vue对数组响应式的处理可以分为两个方面来理解：</p>
<ol>
<li>对数组项的以下7个操作方法做了重写，当数组使用下面方法改变了数组的值，Vue会派发更新通知依赖数组的watcher。<ul>
<li>push</li>
<li> pop</li>
<li> shift</li>
<li> unshift</li>
<li> splice</li>
<li> sort</li>
<li> reverse</li>
</ul>
</li>
<li>数组项的值如果是对象，会对对象属性进行数据劫持实现响应式，完全走的就是对普通对象属性进行依赖收集，派发更新那一套流程。</li>
</ol>
<p>Vue中不能检测以下数组的变动：</p>
<ol>
<li>利用索引直接设置一个数组项；</li>
<li>修改数组的长度。</li>
</ol>
<p>Vue中的数据响应式，实际上是通过对对象属性进行的数据劫持，而且无论是数组还是对象，响应式都是在初始化的时候完成的。Vue希望开发者可以提前声明所有的响应式属性，可以让响应式更可控。</p>
<ol>
<li><p>数组项并不是一个对象的属性，在Vue中是不具有响应式的，在对这个数组项直接赋值的时候，数组值会改变，但并不会触发数组的setter方法。</p>
<p>⚠️如果这个数组项的值是一个对象，那这个对象里面的属性值是响应式的。</p>
</li>
<li><p>修改数组的长度，数组值会改变，但并不会触发数组的setter方法。新数组中只有数组项里还存在的对象属性是响应式的。</p>
</li>
</ol>
<p>与其说Vue不能检测上面两种方式的变化，不如说Vue不想检测，尤大给的原因是性能代价和获得的用户体验收益不成正比。其实也好理解，对数据项直接赋值和修改数组的长度这两种方式都太不可控了。</p>
<h4 id="数组响应式的实现"><a href="#数组响应式的实现" class="headerlink" title="数组响应式的实现"></a>数组响应式的实现</h4><p>在对数组类型的数据进行响应式处理之前，先往数组上绑定了数原型上有的一些方法和属性。这些方法和属性中有7个方法是被Vue做了重写的。因为这7个方法会改变数组本身的值，而Vue根本就没有对数组项这个维度进行响应式处理，所以不会触发数组的setter方法。</p>
<p>为了处理这种情况，使数组在用的这7种方法改变值的时候会触发依赖更新，Vue将这几个方法做了一个重写。</p>
<p>其中pop、shift、sort、reverse四个方法，因为没有添加数组项，所以重写的步骤很简单，就是执行方法、手动派发更新和返回方法的结果值。</p>
<p>而push、unshift和splice方法因为添加了数据项，所以重写的步骤多了一项，简单来讲就是执行方法、将新增的数据项进行响应式处理、手动派发更新和返回方法的结果值。</p>
<p>往目标数组中绑定这些方法和属性时，根据浏览器是否支持__proto__，分为了两种处理方法。</p>
<ol>
<li>支持__proto__：调用protoAugment方法通过原型式继承的方式，将目标数组的原型指向改造后的数组的实例，这个实例中既有数组的所有属性和方法，又有重写了的7个方法，这种方式是将方法和属性绑定在目标的原型链上。</li>
<li>不支持__proto__：调用copyAugment方法，通过def函数，遍历改造后的数组实例，将方法和属性挂在到目标数组的属性上。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>出于对性能的考虑，没有直接用Object.defineProperty去监听数组，但是需要知道Object.defineProperty是具备这个能力的。Vue2.x通过对常见的7种方法进行了重写，来实现对数组项的监听。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/07/Vue2.x%E7%9A%84Virtual%20DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/07/Vue2.x%E7%9A%84Virtual%20DOM/" class="post-title-link" itemprop="url">Vue2.x的Virtual DOM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-07 11:36:00" itemprop="dateCreated datePublished" datetime="2023-11-07T11:36:00+08:00">2023-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2023/11/07/Vue2.x%E7%9A%84Virtual%20DOM/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的Virtual DOM" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/11/07/Vue2.x%E7%9A%84Virtual%20DOM/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/11/07/Vue2.x%E7%9A%84Virtual%20DOM/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>浏览器中的DOM的设计是非常复杂的，当我们频繁的去做DOM更新的时候，会产生一定的性能问题。</p>
<p>而Virtual DOM就是一个用js对象去描述一个DOM节点，对Virtual DOM的操作代价会少很多。</p>
<p>这个设计在react中也有用到，在Vue中Virtual DOM是用VNode这么一个Class去描述的，借鉴了⼀个开源库 snabbdom 的实现，然后加⼊了⼀些 Vue.js 特⾊的东⻄。</p>
<p>⚠️ 使用了虚拟DOM不一定会比直接渲染真实DOM快。举个🌰：一些很明显直接替换DOM的情况下，用虚拟DOM+diff算法，明显是会更慢的。所以严谨的说法是，在复杂视图情况下，使用虚拟DOM+diff算法可以找到DOM树变更的地方，复用之前的DOM，是可以减少DOM的操作使渲染速度更快的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/07/Vue2.x%E7%9A%84nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/07/Vue2.x%E7%9A%84nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Vue2.x的nextTick实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-07 11:36:00" itemprop="dateCreated datePublished" datetime="2023-11-07T11:36:00+08:00">2023-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2023/11/07/Vue2.x%E7%9A%84nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的nextTick实现原理" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/11/07/Vue2.x%E7%9A%84nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/11/07/Vue2.x%E7%9A%84nextTick%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在下次DOM更新循环结束之后执行延迟回调。</p>
<p>在修改数据之后立即使用这个方法，获取更新后的DOM。实际上在派发更新过程中，同步任务执行之后会执行nextTick方法，参数是一个watcher队列执行函数。目的是当本次事件循环中所有的数据变化完成后，异步批量执行watcher队列的回调来实现DOM更新。所以在修改数据之后立即使用这个方法，就相当于nextTick执行更新了DOM的回调之后，再来执行这个nextTick里面的回调函数。</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>需要在视图更新之后，基于新的视图进⾏操作。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>nextTick接收一个函数作为参数，这个函数也可以理解成一个回调函数。nextTick内部其实存储回调函数的一个队列数组，当外面执行同步执行几个nextTick方法的时候，会将这几个nextTick方法的参数存储到回调函数队列中。然后在nextTick的内部会创建一个异步任务。</p>
<p>运行环境不同生成的异步任务的方式和结果也可能不同，具体的顺序如下：</p>
<ol>
<li>判断是否支持Promise，如果支持就在Promise.then方法的回调中去遍历执行队列数组里的回调函数；</li>
<li>判断是否支持MutationObserver，如果支持就内部创建一个DOM元素，模拟修改DOM元素，以这种方式来执行监听DOM变化的回调函数，在这个回调函数中遍历执行队列数组里的回调函数；</li>
<li>判断是否支持setImmediate，如果支持就在setImmediate回调中遍历执行队列数组里的回调函数；</li>
<li>如果以上几种都不支持，setTimeout回调中遍历执行队列数组里的回调函数。</li>
</ol>
<p>前面两种方式生成的异步任务是微任务，后面两种生成的异步任务是宏任务。Vue2.x不同的版本对于这个过程的实现可能会有细微差异，但是目的就是生成一个异步任务，这个任务执行的时间越早越好。</p>
<p>nextTick还有一个实现细节，就是当参数没传且运行环境支持Promise的时候，会返回一个Promise的实例，这个小功能可以按需使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/07/Vue2.x%E7%9A%84patch%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/07/Vue2.x%E7%9A%84patch%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Vue2.x的patch方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-07 11:36:00" itemprop="dateCreated datePublished" datetime="2023-11-07T11:36:00+08:00">2023-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2023/11/07/Vue2.x%E7%9A%84patch%E6%96%B9%E6%B3%95/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的patch方法" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/11/07/Vue2.x%E7%9A%84patch%E6%96%B9%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/11/07/Vue2.x%E7%9A%84patch%E6%96%B9%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>将VNode渲染成真实的DOM</p>
<h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><h5 id="patch方法"><a href="#patch方法" class="headerlink" title="patch方法"></a>patch方法</h5><p>patch可以理解成打补丁的意思，在patch方法中采用diff算法比较新旧节点，一边比较一边给真实的DOM打补丁。</p>
<h5 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h5><p>diff算法用来比较新旧节点，比较只会在同层级比较，不会跨层级比较，这个是相对于传统diff算法的一个很大提升。</p>
<h6 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h6><ul>
<li><p>判断两节点是否值得比较（sameVNode），值得比较则执行patchVNode方法。这个方法做了如下事情：</p>
<ol>
<li><p>找到当前oldVNode对应的真实节点，称为el；</p>
</li>
<li><p>判断VNode和oldVNode是否指向同一个对象，如果是，直接返回；</p>
</li>
<li><p>如果两者都是文本节点且不相等，将el的文本节点设置为VNode的文本节点；</p>
</li>
<li><p>如果oldVNode有子节点而VNode没有，删除el的子节点；</p>
</li>
<li><p>如果oldVNode没有子节点而VNode有，则将VNode的子节点生成真实节点，添加到el；</p>
</li>
<li><p>如果两者都有子节点，则通过updateChildren函数比较子节点。由于updateChildren方法是diff中相对复杂的一部分，拎出来单独分析一下。</p>
</li>
</ol>
</li>
<li><p>不值得比较则用VNode替换oldVNode。具体流程如下：</p>
<ol>
<li>找到当前oldVNode对应的真实节点以及该节点的父节点；</li>
<li>根据VNode生成新节点；</li>
<li>将新节点添加到父节点；</li>
<li>移除旧节点。</li>
</ol>
</li>
</ul>
<h5 id="updateChildren方法"><a href="#updateChildren方法" class="headerlink" title="updateChildren方法"></a>updateChildren方法</h5><p>updateChildren方法用来给新旧VNode都有子节点的情况打补丁。可以将新旧VNode理解成两个数组，以旧数组为基础，通过删除、移动、插入的方式，将旧数组的值转换成新数组的值。</p>
<p>⚠️这里的值指的不是两个数组所在的存储地址，只是数组项的值。而且每次删除、移动、插入的时候都会操作真实DOM。</p>
<h6 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h6><p>旧数组：[oldS，…，oldE]</p>
<p>新数组：[S, …, E]</p>
<p>其中oldS和oldE是待匹配旧节点的开始子节点和结束子节点，S和E是待匹配新节点的开始子节点和结束子节点。这里的oldS、oldE、S和E在diff过程中是会变的，可以理解成一个变量或者一个代号。因为在diff过程中，如果新旧子节点已经匹配过了，会从待匹配的新旧节点列表中移除。</p>
<p> 可以分为5个匹配方式来对比是否是sameVNode，来按顺序完成匹配：</p>
<ol>
<li><p>旧首新首对比：匹配成功会将旧结束子节点移动到真实DOM中目前可供选择位置的最前，因为不能影响到已经patch好的子节点位置，然后移除待匹配的新旧节点列表中的开始子节点；</p>
</li>
<li><p>旧尾旧尾对比：匹配成功会将旧开始子节点移动到真实DOM中目前可供选择位置的最后，因为不能影响到已经patch好的子节点位置，然后移除待匹配的新旧节点列表中的结束子节点；</p>
</li>
<li><p>旧首新尾对比：匹配成功会将旧开始子节点移动到真实DOM中目前可供选择位置的最后，因为不能影响到已经patch好的子节点位置，然后移除待匹配的旧节点列表中的开始子节点和新节点列表中的结束子节点；</p>
</li>
<li><p>旧尾新首对比：匹配成功会将旧结束子节点移动到真实DOM中目前可供选择位置的最前，因为不能影响到已经patch好的子节点位置，然后移除待匹配的旧节点列表中的结束子节点和新节点列表中的开始子节点；</p>
</li>
<li><p>如果上面四种没有匹配成功会分成两种情况：</p>
<ul>
<li>如果新旧子节点都存在key，会根据旧节点的key生成一张hash表，用S的key与hash表做匹配，判断是否时为sameVNode。<ol>
<li>匹配成功：将匹配成功的节点移动到真实DOM中目前可供选择位置的最前，因为不能影响到已经patch好的子节点位置，然后移除待匹配旧节点中已经匹配到S的key的节点和待匹配新节点中的S；</li>
<li>匹配失败：将S生成真实DOM节点，插入到目前可供选择位置的最前，也就是oldS的位置，然后然后移除待匹配新节点中的S。</li>
</ol>
</li>
<li>如果没有key，将直接将遍历待匹配旧节点列表。<ol>
<li>匹配成功：将匹配成功的节点移动到真实DOM中目前可供选择位置的最前，因为不能影响到已经patch好的子节点位置，然后移除待匹配旧节点中已经匹配到S的节点和待匹配新节点中的S；</li>
<li>匹配失败：将S生成真实DOM节点，插入到目前可供选择位置的最前，也就是oldS的位置，然后然后移除待匹配新节点中的S。</li>
</ol>
</li>
</ul>
<p>⚠️ 常见场景解析：</p>
<ul>
<li><p>v-for的时候设置key，就是为了如果首首、尾尾、首尾、尾首这四种匹配方式没匹配到的时候，可以使用key来更快地寻找可复用的节点，而不是只能用遍历的方式。</p>
</li>
<li><p>不能用index索引来做key的原因也是这个，因为用index索引来做key，并不能找到想要复用的旧节点，甚至可能会导致一个子节点都复用不了，起到负面作用。</p>
<p>举个🌰：一个数组长度是偶数的数组用index做key，被反序后，会给每一个子节点匹配到一个错误的不可复用的子节点，使diff的效率比没加key更低。</p>
</li>
</ul>
</li>
<li><p>循环上面的过程，不断的将待匹配节点列表向内部收缩。当待匹配的新旧节点列表有一个先被清空的话，将执行下面判断。</p>
<p>⚠️ 这里说的待匹配列表只是为了帮助理解来提出的一个概念，并没有一个真实的变量来存储这个待匹配列表。真实在数组中描述待匹配列表，是通过移动开始节点和结束节点的指针位置来实现。</p>
<ol>
<li>待匹配的旧节点列表被清空，也就是oldStartIdx &gt; oldEndIdx，说明旧节点都被patch了，还有新节点没被处理到，批量新增待匹配的新节点；</li>
<li>待匹配的新节点列表被清空，也就是newStartIdx &gt; newEndIdx，说明新节点都被patch了，还有多余的旧节点没被处理到，批量删除待匹配的旧节点。</li>
</ol>
</li>
</ol>
<h6 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h6><p>完成这一些复杂的匹配，就是为了更快更多地复用DOM的旧节点，因为DOM节点的创建开销是很大的。其实更快和更多是矛盾的，Vue找到了一个平衡点，比较只会在同层级进行, 不会跨层级。</p>
<h4 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h4><h5 id="首次渲染"><a href="#首次渲染" class="headerlink" title="首次渲染"></a>首次渲染</h5><p>父子组件在加载的时候，生命周期执行的顺序为：</p>
<p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted。</p>
<p>下面从首次渲染的流程角度，来分析为什么是这个顺序。</p>
<p>首次渲染时，父组件render生成父组件的VDOM，然后会执行父组件的patch方法，目的是将VDOM渲染成DOM。</p>
<p>在执行父组件patch方法解析到子组件VNode的时候，子组件VNode是被父组件的render函数生成的组件类型的VNode。在生成组件类型的组件过程中，完成了构造子类构造函数、安装组件钩子函数和实例化VNode，生成的子组件是没有children的，这个时候不知道子组件的细节。</p>
<p>patch到子组件VNode时，会触发子组件生命周期中的init hook，在init hook中开始对子组件进行挂载，将子组件当作一个新的Vue实例，重新进行初始化、render生成VDOM，然后执行子组件的patch。</p>
<p>解析子组件VNode这个过程，以深度优先的算法，将所有的子孙组件挂载到根实例上。有子组件就先完成子组件的完整挂载过程，等子组件完成挂载后再回到父组件完成父组件的挂载。从这个逻辑来理解，上面的生命周期执行顺序就很好理解了。</p>
<p>首次渲染patch过程比较简单，就是简单的插入，因为旧节点为空。</p>
<p>完成patch之后 ，将更新后的VNode数据赋值给oldVNode。</p>
<h5 id="数据更新的时候"><a href="#数据更新的时候" class="headerlink" title="数据更新的时候"></a>数据更新的时候</h5><p>数据更新触发渲染watcher更新的时候，会重新生成render函数，生成新的VNode，供patch方法为旧DOM打补丁使用。即使数据更新发生在很多组件上，每次执行渲染watcher更新，重新patch的时候关注的都只是当前组件。</p>
<p>⚠️ 每个组件都有自己的渲染watcher。</p>
<p>数据更新时patch过程就会相对复杂，会更充分使用到diff算法的细节。oldVNode就是上次渲染时的VNode，VNode就是本次重新生成的VNode，通过diff算法，一边一边比较一边给真实的DOM打补丁。</p>
<p>完成patch之后 ，将更新后的VNode数据赋值给oldVNode。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/07/Vue2.x%E7%9A%84render%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/07/Vue2.x%E7%9A%84render%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Vue2.x的render方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-07 11:36:00" itemprop="dateCreated datePublished" datetime="2023-11-07T11:36:00+08:00">2023-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          
            <span id="/2023/11/07/Vue2.x%E7%9A%84render%E6%96%B9%E6%B3%95/" class="post-meta-item leancloud_visitors" data-flag-title="Vue2.x的render方法" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/11/07/Vue2.x%E7%9A%84render%E6%96%B9%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/11/07/Vue2.x%E7%9A%84render%E6%96%B9%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>render方法将Vue实例渲染成一个虚拟Node，在生成VNode的时候完成了渲染watcher的依赖的收集。</p>
<p>patch方法将VNode转换为真正的DOM节点。</p>
<h4 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h4><p>在Vue实例挂载的时候，执行render方法来生成VNode。而在开发的时候，开发者大多数情况并不是自己手写的render函数，而是写的template模版或者el。在mounted的方法中，会将template模版编译成render方法，如果是el会多一个步骤，得先从el中提取出template模版。</p>
<h4 id="本集看点"><a href="#本集看点" class="headerlink" title="本集看点"></a>本集看点</h4><h5 id="render渲染VNode主要步骤"><a href="#render渲染VNode主要步骤" class="headerlink" title="render渲染VNode主要步骤"></a>render渲染VNode主要步骤</h5><ol>
<li><p>将children参数规范化：由于生成VNode的参数中children必须是VNode类型的，而下面几种情况下children不符合条件，所以在根据参数实例化VNode之前需要将children规范化成一个类型为VNode的Array。</p>
<ul>
<li><p>render函数是编译生成的，理论上编译生成的children已经是VNode类型的，但是当组件是函数式组件时，返回的是一个数组而不是一个根结点，所以需要用Array.prototype.concat方法将整个children数组打平，让深度只有一层。</p>
<p>⚠️只有这一种情况，调用simpleNormalizeChildren方法来实现children规范化。</p>
</li>
<li><ol>
<li>render函数是用户手写的，当children只有一个基础类型节点的时候，会调用createTextVNode方法创建一个文本节点的VNode；</li>
<li>render函数是手写的，当编译slot或者v-for的时候。</li>
</ol>
<p>⚠️只有这两种情况，调用normalizeChildren方法来实现children规范化。</p>
</li>
</ul>
</li>
<li><p>创建VNode实例</p>
<p>为每一个html标签创建一个VNode，顺序是先子后父，从上到下。可以理解成按照标签闭合的顺序，依次创建VNode，一个template模版中的根标签生成的就是当前组件的VNode树，也称为VDOM。</p>
<p>对tag进行判断，创建不同类型的VNode：</p>
<ul>
<li>如果是字符串类型且是内置的节点，直接创建普通VNode;</li>
<li>如果是字符串类型且是已注册的组件名，则通过createComponent方法创建一个组件类型的VNode;</li>
<li>如果是字符串类型，又不是上面两种情况，创建一个未知标签的VNode;</li>
<li>如果是组件类型，则通过createComponent方法创建一个组件类型的VNode。</li>
</ul>
</li>
</ol>
<h5 id="创建组件类型VNode主要步骤"><a href="#创建组件类型VNode主要步骤" class="headerlink" title="创建组件类型VNode主要步骤"></a>创建组件类型VNode主要步骤</h5><p>render渲染VNode可能会生成3种类型的VNode：</p>
<ol>
<li>普通类型VNode;</li>
<li>未知标签VNode;</li>
<li>组件类型VNode。</li>
</ol>
<p>因为前面两种都比较简单，这里着重分析组件类型VNode。通过createComponent方法将组件渲染成VNode主要做了3个事情：</p>
<ol>
<li><p>构造子类构造函数：开发者在写组件的时候，通常都是创建一个普通的对象，Vue内部使用Vue.extend将这个普通对象做了扩展，使这个对象可以像Vue实例一样可以完成初始化、挂载、渲染等一系列功能。</p>
<p>Vue.extend的作用是构造一个Vue的子类，使用一种非常经典的原型继承的方式把一个纯对象转换成了一个继承于Vue的构造器Sub并返回，然后对Sub对象本身扩展一些属性，如扩展options、添加全局API，并且对配置做一些初始化工作。</p>
<p>最后对这个Sub构造函数做了缓存，避免多次执行Vue.extend的时候对同一个子组件重复构造。在执行父组件patch方法解析到组件VNode的时候，会触发子组件生命周期中的init hook，在init hook中开始对子组件进行挂载，再走到子组件初始化逻辑。</p>
</li>
</ol>
<ol start="2">
<li><p>安装组件钩子函数：将组件特有的几个钩子和Vue实例的生命周期钩子合并。</p>
<p>在实例化Vue的时候，Vue的挂载是在初始化完成的时候，这个是一个同步的事件，有一个固定的地方可以执行这块逻辑，不需要钩子函数来回调Vue的挂载操作。</p>
<p>而子组件的挂载时机，是在父组件patch的过程中。子组件为了更好的管理自己的生命周期，添加了init、prepatch、insert和destroy四个生命周期钩子，分别对应初始化、更新、挂载完成、销毁。</p>
<p>在父组件VNode执行执行patch的时候会执行上面的钩子函数，这就可以实现组件的渲染。这里需要注意的一点是Vue实例原有的几种生命钩子是可以正常使用的，如mounted钩子函数会在insert钩子执行的时候被调用。</p>
</li>
</ol>
<ol start="3">
<li><p>实例化VNode：实例化一个VNode，不过需要注意的是组件的VNode是没有children的。因为父组件render方法中，是看不到子组件内部结构的，只会为子组件生成一个组件VNode。</p>
<p>父组件render方法生成VDOM之后，会执行到patch方法，在patch过程中会将子组件当作一个新的Vue实例，重新进行初始化、render生成VDOM，在这个子组件render方法生成的VDOM中，才会有children。</p>
<p>也就是说render方法在解析子组件的时候，只会将子组件生成一个组件VNode，不会关心子组件是否有子组件，子组件是否有子组件，这个事情由子组件来关心。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/07/Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/07/Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Node的事件循环机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-07 11:36:00" itemprop="dateCreated datePublished" datetime="2023-11-07T11:36:00+08:00">2023-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Node/" itemprop="url" rel="index"><span itemprop="name">Node</span></a>
                </span>
            </span>

          
            <span id="/2023/11/07/Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="post-meta-item leancloud_visitors" data-flag-title="Node的事件循环机制" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/11/07/Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/11/07/Node%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Node中的Event Loop和浏览器中的是完全不相同的东西。Node采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv。libuv是一个事件驱动的跨平台抽象层，封装了不同操作系统的一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。</p>
<h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>V8引擎解析js脚本，解析后的代码调用Node API。libuv库负责Node API的执行，将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的返回结果返回给V8引擎，再由V8引擎将结果返回给用户。</p>
<h4 id="事件循环的阶段顺序"><a href="#事件循环的阶段顺序" class="headerlink" title="事件循环的阶段顺序"></a>事件循环的阶段顺序</h4><p>输入数据阶段 incoming data -&gt; 轮询阶段 poll -&gt;  检查阶段 check -&gt; 关闭事件回调阶段 close callback -&gt; 定时器检测阶段 timer -&gt;  I/O事件回调阶段 I/O callbacks -&gt; 闲置阶段 idle,prepare -&gt; 轮询阶段 poll …</p>
<h4 id="六大阶段概述"><a href="#六大阶段概述" class="headerlink" title="六大阶段概述"></a>六大阶段概述</h4><ul>
<li>定时器检测阶段 timer：执行timer的回调，即setTimeout、setInterval里面的回调函数；</li>
<li>I/O事件回调阶段 I/O callbacks：执行上一轮循环中未被执行的一些I/O回调；</li>
<li>闲置阶段 idle, prepare：仅系统内部使用；</li>
<li>轮询阶段 poll：检索新的I/O事件，执行与I/O相关的回调；</li>
<li>检查阶段 check：setImmediate()回调函数在这里执行；</li>
<li>关闭事件回调阶段 close callback：一些关闭的回调函数，如socket.on(‘close’, …)。</li>
</ul>
<p>⚠️每个阶段都有一个先进先出队列来执行回调。通常情况下，当事件循环进入给定的阶段后，将执行该阶段的任何操作，然后执行该阶段队列中的回调。当该队列执行完毕或达到最大回调限制时，事件循环将移动到下一阶段。</p>
<h4 id="三大阶段详述"><a href="#三大阶段详述" class="headerlink" title="三大阶段详述"></a>三大阶段详述</h4><p>日常开发中绝大部分的异步任务都是在poll、check、timer这三个阶段，重点分析一下。</p>
<h5 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h5><p>timer阶段会执行setTimeout、setInterval里面的回调函数，并且是由poll阶段控制的。在Node中定时器指定的时间也不是准确时间，只能是尽快执行。</p>
<h5 id="check"><a href="#check" class="headerlink" title="check"></a>check</h5><p>setImmediate()回调函数在这里执行。</p>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>poll阶段是一个至关重要的阶段，执行逻辑相对复杂，具体流程如下。</p>
<p>在这一阶段中，系统会做两件事情：</p>
<ol>
<li>回到timer阶段执行回调：设定了timer且poll队列为空，如果有timer超时，则会回到timer阶段；</li>
<li>执行I/O回调（没满足上面的条件就会走下面流程）：<ul>
<li>如果poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制；</li>
<li>如果poll队列为空时，也有两种情况：<ul>
<li>如果有setImmediate回调需要执行，poll阶段会停止并且进入到check阶段执行回调；</li>
<li>如果没有setImmediate回调需要执行，会等待回调被加入队列中并立即执行回调。这里有个超时时间设置，防止一直等待下去。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="分析差别"><a href="#分析差别" class="headerlink" title="分析差别"></a>分析差别</h4><p>Node中的事件循环和浏览器的事件循环，差别就在于浏览器中事件循环中异步任务只分为了宏任务和微任务，他们执行的是同属于一个阶段的，简单理解为渲染之前的阶段。而Node中的不同的宏任务会有不同的执行阶段，且微任务的执行时机跟Node的版本还有关系。</p>
<h5 id="Node中宏任务和微任务"><a href="#Node中宏任务和微任务" class="headerlink" title="Node中宏任务和微任务"></a>Node中宏任务和微任务</h5><h6 id="宏任务-macro-task"><a href="#宏任务-macro-task" class="headerlink" title="宏任务 macro-task"></a>宏任务 macro-task</h6><ul>
<li>setTimeout：timers阶段执行；</li>
<li>setInterval：timers阶段执行；</li>
<li>setImmediate：check阶段执行；</li>
<li>script 整体代码：执行同步代码，将不同类型的异步任务添加到任务队列；</li>
<li>I/O 操作：poll阶段执行。</li>
<li>…</li>
</ul>
<h6 id="微任务-micro-task"><a href="#微任务-micro-task" class="headerlink" title="微任务 micro-task"></a>微任务 micro-task</h6><ul>
<li>process.nextTick：与普通的微任务有区别，在微任务队列执行之前执行；</li>
<li>Promise.then;</li>
<li>…</li>
</ul>
<h5 id="版本差异总结"><a href="#版本差异总结" class="headerlink" title="版本差异总结"></a>版本差异总结</h5><p>node11之前，每一个event loop阶段完成后都会先清空nextTick队列，再清空微任务队列。</p>
<p>node11之后，process.nextTick是微任务的一种，但还是执行顺序优先于Promise.then。在异步任务的执行方面，已经在向浏览器看齐，最大的改变是微任务的执行时机发生变化了。当执行完一个宏任务时，生成的微任务会在这个宏任务出队列的时候立即执行，而不是等到一个event loop阶段再去执行。</p>
<p>⚠️虽然node11之后，异步方法的执行方面已经在向浏览器看齐了，但是不同的宏任务还是位于不同的阶段去执行，这个跟浏览器还是很大差别的。</p>
<h6 id="举几个🌰"><a href="#举几个🌰" class="headerlink" title="举几个🌰"></a>举几个🌰</h6><ol>
<li>微任务执行时机</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout1&#x27;</span>)</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise resolve&#x27;</span>))</span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next tick1&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout2&#x27;</span>)</span><br><span class="line">    process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next tick2&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout3&#x27;</span>));</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout4&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// node11之前：timeout1 -&gt; timeout2 -&gt; timeout3 -&gt; timeout4 -&gt; next tick1 -&gt; next tick2 -&gt; promise resolve</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// node11之后：timeout1 -&gt; next tick1 -&gt; promise resolve -&gt; timeout2 -&gt; next tick2 -&gt; timeout3 -&gt; timeout4</span></span><br></pre></td></tr></table></figure>

<p>过程分析：</p>
<p>node11之前，在check阶段执行setImmediate的时候遇到的微任务都会先放入微任务队列，等check阶段所有的setImmediate执行完成之后，在进入关闭事件回调阶段 close callback之前，会讲所有的微任务清空。</p>
<p>node11之后，在check阶段执行setImmediate的时候遇到的微任务都在当前的宏任务执行完成之后，马上清空该宏任务生成的微任务。等微任务清空后，再去执行下一个宏任务。</p>
<ol start="2">
<li>setTimeout 和 setImmediate</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="keyword">function</span> <span class="title function_">immediate</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行结果：结果不固定</span></span><br></pre></td></tr></table></figure>

<p>对于以上代码来说，setTimeout可能执行在前，也可能执行在后。首先科普一下，setTimeout(fn, 0) === setTimeout(fn, 1)，这个是源码决定的。</p>
<p>因为进入事件循环也是需要时间的，如果在进入时间循环的准备阶段花费了大于1ms的时间，那么此时就成了一个timer超时且poll队列为空的状态，会回到timer阶段执行setTimeout回调。</p>
<p>如果进入时间循环的准备阶段花费了小于1ms的时间，不满足timer超时且poll队列为空的状态，就会还是处于poll阶段执行I/O回调。由于poll队列为空，且有setImmediate回调，就直接跳转到check阶段执行immediate回调函数。</p>
<ol start="3">
<li>异步I/O回调中的setTimeout 和 setImmediate</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs =<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./reptileServer.js&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeout</span> () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">    <span class="title function_">setImmediate</span>(<span class="keyword">function</span> <span class="title function_">immediate</span> () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行结果：immediate -&gt; timeout</span></span><br></pre></td></tr></table></figure>

<p>这个🌰跟上面看似只有细微差别，实际上会有完全不同的执行结果，会稳定先执行setImmediate回调。因为在I/O回调生成setTimeout和setImmediate宏任务时，poll队列不为空，所以不管timer是否超时都不会进入到timers阶段。等队列为空时，会直接到check阶段执行setImmediate回调。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/31/%E5%BC%95%E7%94%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/31/%E5%BC%95%E7%94%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89js/" class="post-title-link" itemprop="url">引用文件夹下所有js</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-31 00:00:00" itemprop="dateCreated datePublished" datetime="2021-12-31T00:00:00+08:00">2021-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-07 11:36:00" itemprop="dateModified" datetime="2023-11-07T11:36:00+08:00">2023-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          
            <span id="/2021/12/31/%E5%BC%95%E7%94%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89js/" class="post-meta-item leancloud_visitors" data-flag-title="引用文件夹下所有js" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/12/31/%E5%BC%95%E7%94%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89js/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/12/31/%E5%BC%95%E7%94%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89js/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在index.js中export同级js文件中暴露的数据:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js </span></span><br><span class="line"><span class="keyword">const</span> hooks = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>.<span class="title function_">context</span>(<span class="string">&#x27;./&#x27;</span>, <span class="literal">false</span>, <span class="regexp">/\.js$/</span>)</span><br><span class="line"><span class="keyword">const</span> keys = context.<span class="title function_">keys</span>().<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item !== <span class="string">&#x27;./index.js&#x27;</span>)</span><br><span class="line">keys.<span class="title function_">forEach</span>(<span class="function"><span class="params">filePath</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> file = <span class="title function_">context</span>(filePath).<span class="property">default</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(hooks, &#123; [file.<span class="property">name</span>]: file &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> hooks</span><br></pre></td></tr></table></figure>



<p>使用方式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hooks <span class="keyword">from</span> <span class="string">&#x27;xxx/xxx/index.js&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> &#123; xxx, xxx, xxx &#125; = hooks</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/20/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAPLugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/20/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAPLugin/" class="post-title-link" itemprop="url">手写一个Plugin</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-20T00:00:00+08:00">2021-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-07 11:36:00" itemprop="dateModified" datetime="2023-11-07T11:36:00+08:00">2023-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/webpack/" itemprop="url" rel="index"><span itemprop="name">webpack</span></a>
                </span>
            </span>

          
            <span id="/2021/08/20/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAPLugin/" class="post-meta-item leancloud_visitors" data-flag-title="手写一个Plugin" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/08/20/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAPLugin/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/08/20/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAPLugin/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-配置文件中使用插件"><a href="#1-配置文件中使用插件" class="headerlink" title="1.配置文件中使用插件"></a>1.配置文件中使用插件</h3><p>webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CopyWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;./plugins/CopyWebpackPlugin.js&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CopyWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">from</span>: <span class="string">&#x27;public&#x27;</span>,</span><br><span class="line">      <span class="attr">to</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * &#x27;**&#x27;可以匹配任意数量的字符，包括/</span></span><br><span class="line"><span class="comment">       * 因为ignore是作为参数传给globby，所以规则在globby中定义</span></span><br><span class="line"><span class="comment">       */</span> </span><br><span class="line">      <span class="attr">ignore</span>: <span class="string">&#x27;**/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-plugin文件"><a href="#2-plugin文件" class="headerlink" title="2.plugin文件"></a>2.plugin文件</h3><p>CopyWebpackPlugin.js：将静态文件打包到dist目录</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globby = <span class="built_in">require</span>(<span class="string">&#x27;globby&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件资源转化成webpack compilation可以识别的格式</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">RawSource</span> &#125; = webpack.<span class="property">sources</span></span><br><span class="line"><span class="comment">// 将读取文件函数基于Promise再次封装</span></span><br><span class="line"><span class="keyword">const</span> readFilePromise = util.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件都是一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CopyWebpackPlugin</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> (options) &#123;</span><br><span class="line">        <span class="comment">// 从构造函数参数中获取webpack.config.js中的配置</span></span><br><span class="line">        <span class="comment">// options: &#x27;&#123; from: &#x27;public&#x27;, to: &#x27;&#x27;, ignore: &#x27;**/index.html&#x27; &#125;&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">options</span> = options</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * apply函数中根据需求在合适的生命周期注册回调函数</span></span><br><span class="line"><span class="comment">     * 函数接收的参数是一个Compiler实例，Compiler扩展自Tapable。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Tapable实现了发布订阅模式:</span></span><br><span class="line"><span class="comment">     * 1.实例属性hooks是一个对象，key为事件名称， value可以指定该事件数组的执行方式（同步并行/异步并行/...）；</span></span><br><span class="line"><span class="comment">     * 2.使用tap/tapAsync/tapPromise往hooks里的事件注册回调；</span></span><br><span class="line"><span class="comment">     * 3.使用call/callAsync/promise触发hooks里的事件。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 在webpack中Tapable创建了各种钩子，插件将自己的方法注册到对应的钩子上，</span></span><br><span class="line"><span class="comment">     * 相当于往实例的hooks里的事件注册回调，交给webpcak，</span></span><br><span class="line"><span class="comment">     * webpack编译时，不同的生命周期触发不同的事件。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    apply (compiler) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * thisCompilation钩子：</span></span><br><span class="line"><span class="comment">         * 生命周期：初始化compilation时调用，在触发compilation事件之前调用</span></span><br><span class="line"><span class="comment">         * 事件数组执行方式：SyncHook 串行同步，出没出错都往下执行</span></span><br><span class="line"><span class="comment">         * 回调参数：compilation，compilationParams</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compiler.<span class="property">hooks</span>.<span class="property">thisCompilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;CopyWebpackPlugin&#x27;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Compilation模块会被Compiler用来创建新的编译（或新的构建）</span></span><br><span class="line"><span class="comment">             * compilation实例的additionalAssets钩子：</span></span><br><span class="line"><span class="comment">             * 生命周期：可以为compilation创建额外asset</span></span><br><span class="line"><span class="comment">             * 事件数组执行方式：AsyncSeriesHook 串行异步</span></span><br><span class="line"><span class="comment">             * cb: 调用表示任务完成</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compilation.<span class="property">hooks</span>.<span class="property">additionalAssets</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;CopyWebpackPlugin&#x27;</span>, <span class="keyword">async</span> callback =&gt; &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; <span class="keyword">from</span>, to = <span class="string">&#x27;&#x27;</span>, ignore &#125; = <span class="variable language_">this</span>.<span class="property">options</span> || &#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 筛选需要拷贝的所有文件的绝对路径</span></span><br><span class="line">                <span class="keyword">const</span> absoluteFromPath = path.<span class="title function_">resolve</span>(compiler.<span class="property">options</span>.<span class="property">context</span>, <span class="keyword">from</span>)</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * globby函数第一个参数是匹配的绝对路径，第二个参数是配置对象。</span></span><br><span class="line"><span class="comment">                 * 下面配置了ignore属性，设置可以忽略的文件</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">const</span> paths = <span class="keyword">await</span> <span class="title function_">globby</span>(absoluteFromPath, &#123; ignore &#125;)</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(absoluteFromPath)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断文件分类，先简单分为三类：js、css、images </span></span><br><span class="line">                <span class="keyword">const</span> <span class="title function_">judgeType</span> = (<span class="params">path</span>) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> middle = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.<span class="title function_">test</span>(path)) &#123;</span><br><span class="line">                        middle = <span class="string">&#x27;js&#x27;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\.css$/</span>.<span class="title function_">test</span>(path)) &#123;</span><br><span class="line">                        middle = <span class="string">&#x27;css&#x27;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\w(\.gif|\.jpeg|\.png|\.jpg|\.bmp)/i</span>.<span class="title function_">test</span>(path)) &#123;</span><br><span class="line">                        middle = <span class="string">&#x27;image&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> middle</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> files = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">                        <span class="comment">// 遍历文件内容</span></span><br><span class="line">                        paths.<span class="title function_">map</span>(<span class="keyword">async</span> absolutePath =&gt; &#123;</span><br><span class="line">                            <span class="comment">// 获取文件内容</span></span><br><span class="line">                            <span class="keyword">const</span> source = <span class="keyword">await</span> <span class="title function_">readFilePromise</span>(absolutePath)</span><br><span class="line">                            <span class="comment">// 文件名称：webpack.config.js中配置的to + 文件分类 + 获取path的最后一部分</span></span><br><span class="line">                            <span class="keyword">const</span> baseName = path.<span class="title function_">basename</span>(absolutePath)</span><br><span class="line">                            <span class="keyword">const</span> fileName = path.<span class="title function_">join</span>(to, <span class="title function_">judgeType</span>(absolutePath), baseName )</span><br><span class="line">                            <span class="comment">// 将资源转成compilation可识别的格式</span></span><br><span class="line">                            <span class="keyword">const</span> rawSource = <span class="keyword">new</span> <span class="title class_">RawSource</span>(source)</span><br><span class="line">                            <span class="comment">// 输出文件</span></span><br><span class="line">                            compilation.<span class="title function_">emitAsset</span>(fileName, rawSource)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    )</span><br><span class="line">                    <span class="comment">// 成功回调</span></span><br><span class="line">                    <span class="title function_">callback</span>()</span><br><span class="line">                &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                    <span class="comment">// 抛出异常</span></span><br><span class="line">                    <span class="title function_">callback</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;[CopyWebpackPlugin] loading error&#x27;</span>))</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">CopyWebpackPlugin</span></span><br></pre></td></tr></table></figure>



<h3 id="3-调试技巧"><a href="#3-调试技巧" class="headerlink" title="3.调试技巧"></a>3.调试技巧</h3><ol>
<li>Package.json: 配置执行脚本</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="string">&quot;debug&quot;</span>: <span class="string">&quot;node --inspect-brk ./node_modules/webpack/bin/webpack.js --mode development&quot;</span></span><br><span class="line">   ...</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>CopyWebpackPlugin.js: 在需要断点的地方添加debugger</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compiler.<span class="property">hooks</span>.<span class="property">thisCompilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;CopyWebpackPlugin&#x27;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">debugger</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(compilation)</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>控制台执行</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run debug</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>打开网页:  <a target="_blank" rel="noopener" href="https://nodejs.org/en/docs/inspector">https://nodejs.org/en/docs/inspector</a></li>
</ol>
<p><img src="https://raw.githubusercontent.com/whpuEdison/blog/master/static/images/node_debug.png" alt="img"></p>
<ol start="5">
<li>开始调试</li>
</ol>
<p><img src="https://raw.githubusercontent.com/whpuEdison/blog/master/static/images/debugger.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/19/Loader%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="马帅傅">
      <meta itemprop="description" content="道阻且长,行则将至">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上任鹅城">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/19/Loader%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" class="post-title-link" itemprop="url">Loader的执行顺序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-19 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-19T00:00:00+08:00">2021-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-07 11:36:00" itemprop="dateModified" datetime="2023-11-07T11:36:00+08:00">2023-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/webpack/" itemprop="url" rel="index"><span itemprop="name">webpack</span></a>
                </span>
            </span>

          
            <span id="/2021/08/19/Loader%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" class="post-meta-item leancloud_visitors" data-flag-title="Loader的执行顺序" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/08/19/Loader%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/08/19/Loader%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="配置-webpack-config-js"><a href="#配置-webpack-config-js" class="headerlink" title="配置 webpack.config.js"></a>配置 webpack.config.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">   <span class="attr">rules</span>: [ </span><br><span class="line">     &#123; </span><br><span class="line">       <span class="attr">test</span>: <span class="regexp">/\.json$/</span>, </span><br><span class="line">       <span class="attr">use</span>: [<span class="string">&#x27;loader1.js&#x27;</span>, <span class="string">&#x27;loader2.js&#x27;</span>,<span class="string">&#x27;loader3.js&#x27;</span>]</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">resolveLoader</span>: &#123;</span><br><span class="line">   <span class="comment">// 寻找loader所在位置</span></span><br><span class="line">   <span class="attr">modules</span>: [<span class="string">&#x27;node_modules&#x27;</span>, path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;loaders/&#x27;</span>)]</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>



<h3 id="编写-loader-文件"><a href="#编写-loader-文件" class="headerlink" title="编写 loader 文件"></a>编写 loader 文件</h3><h4 id="loader1-js"><a href="#loader1-js" class="headerlink" title="loader1.js"></a>loader1.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行顺序：webpack当前loader链中的pitch方法同步代码执行完成之后，</span></span><br><span class="line"><span class="comment"> * 再从右往左（从下往上）执行loader函数。</span></span><br><span class="line"><span class="comment"> * 注意：异步回调使用this.async，异步回调执行完之后才会下一个loader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">content</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pitch方法不是必须的。</span></span><br><span class="line"><span class="comment"> * 执行顺序: webpack会从左往右（从上往下）执行loader链中的每一个pitch方法。</span></span><br><span class="line"><span class="comment"> * 注意：如果picth方法中有异步代码，webpack执行的时候不会等待，</span></span><br><span class="line"><span class="comment"> * 会将loader链中的pitch方法中同步代码执行完再来执行异步代码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">pitch</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pitch1&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="loader2-js"><a href="#loader2-js" class="headerlink" title="loader2.js"></a>loader2.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * content: 对于第一个执行的loader为资源的内容，非第一个执行的loader为上一个loader的执行结果。</span></span><br><span class="line"><span class="comment"> * map: 可选参数，sourceMap</span></span><br><span class="line"><span class="comment"> * mate: 可选参数，传递给下一个loader数据（在这个例子中下一个loader是loader1） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">content, map, meta</span>) &#123;</span><br><span class="line">    <span class="comment">// 接收pitch传递过来data</span></span><br><span class="line">    <span class="comment">// console.log(this.data.customStr) // 传递给loader函数的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收loader3传递过来的meta数据</span></span><br><span class="line">    <span class="comment">// console.log(meta) // &#123; preLoader: &#x27;loader3&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="title function_">async</span>()</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        <span class="title function_">callback</span>(<span class="literal">null</span>, content, map)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * remainingRequest：当前loader之后的资源请求字符串；</span></span><br><span class="line"><span class="comment"> * previousRequest：当前loader之前经历的loader列表以&#x27;!&#x27;连接的字符串；</span></span><br><span class="line"><span class="comment"> * data: 用于与当前loader函数传递数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">pitch</span> = <span class="function">(<span class="params">remainingRequest, precedingRequest, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * precedingRequest: /Users/xxx/loaders/loader3.js!/Users/xxx/testLoader.json</span></span><br><span class="line"><span class="comment">     * precedingRequest /Users/xxx/loaders/loader1.js</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递给loader函数data数据</span></span><br><span class="line">    <span class="comment">// data.customStr = &quot;传递给loader函数的字符串&quot; </span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pitch2&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async pitch2&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="loader3-js"><a href="#loader3-js" class="headerlink" title="loader3.js"></a>loader3.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">content, map, meta</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    <span class="comment">// 给loader2传递meta数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="literal">null</span>, content, map, &#123; <span class="attr">preLoader</span>: <span class="string">&#x27;loader3&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">pitch</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pitch3&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打包执行结果"><a href="#打包执行结果" class="headerlink" title="打包执行结果"></a>打包执行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pitch1</span><br><span class="line">pitch2</span><br><span class="line">pitch3</span><br><span class="line">3</span><br><span class="line">async pitch2</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="马帅傅"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">马帅傅</p>
  <div class="site-description" itemprop="description">道阻且长,行则将至</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马帅傅</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'CvwUY722HB1rJt3XHzcbMEOc-gzGzoHsz',
      appKey     : 'vsP2YzUdTWIWI9gdYB9UhhUr',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
